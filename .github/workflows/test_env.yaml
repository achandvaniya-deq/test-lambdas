name: 'Deploy'

on:
  push:
    branches:
      - path-ci

env:
  lambda_function_name: '{"lambda_functions/function1" : "function1_lambda" ,"lambda_functions/function2": "function2_lambda" }'



jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      # - name: Check which services were modified
      #   uses: dorny/paths-filter@v2
      #   id: filter
      #   with:
      #     list-files: shell
      #     base: 'path-ci'
      #     filters: |
      #       changed:
      #         - 'lambda_functions/function1/**'
      #         - 'lambda_functions/function2/**'
      
      # - name: Deploy changed services
      #   if: ${{ steps.filter.outputs.changed == 'true' }}
      #   run: |
      #     echo "All changes:"
      #     for i in ${{ steps.filter.outputs.changed_files }}; do echo $i ; done
      
      - name: Deploy changed services
        # if: ${{ steps.filter.outputs.changed == 'true' }}
        run: echo ${{ env.test_var}}
      
#       - name: get unique directories with changes
#         id: transform
#         continue-on-error: false
#         run: |
#           folders=()
#           for f in ${{ steps.filter.outputs.changed_files }}; \
#             do \
#               echo "Adding $(dirname $f) to folders"; \
#               folders+=($(dirname $f)); \
#           done
#           unique_folders=($(printf "%s\n" "${folders[@]}" | sort -u | tr '\n' ' '))
#           echo "directories=$(jq --compact-output --null-input '$ARGS.positional' --args -- ${unique_folders[@]})" >> $GITHUB_OUTPUT
    
#     outputs:
#       directories: ${{ steps.transform.outputs.directories }}

#   print-directories:
#     needs: deploy
#     name: "print directories with changes"
#     runs-on: ubuntu-latest
#     strategy:
#       matrix:
#         directories: ${{ fromJson(needs.deploy.outputs.directories) }}
#     steps:
#       - name: directories list
#         run: echo ${{ fromJson(env.lambda_function_name)[matrix.directories] }}

#   test-build:
#     runs-on: ubuntu-latest
#     name: Test Lambda function
#     steps:
#       - name: Check build status
#         run: exit 0




# env:
#   FUNCTION_NAME: marketscan-ccf-staging-job-management
#   TARGET_BUCKET: marketscan-ccf-staging-bdata-manage
#   ZIP_FILE: lambda_function_payload.zip

# jobs:
#   test-build:
#     runs-on: ubuntu-latest
#     name: Test Lambda function
#     steps:
#       - name: Check build status
#         run: exit 0

#   deploy_zip:
#     name: Deploy lambda function
#     runs-on: ubuntu-latest
#     needs: [test-build]
#     if: github.event_name == 'push'
#     strategy:
#       matrix:
#         go-version: [1.19.x]
#     steps:
#       - name: checkout source code
#         uses: actions/checkout@v1

#       - name: Build zip
#         run: |
#           cd ${{ fromJson(env.lambda_function_name)[matrix.directories] }}
#           zip -r ${{ env.ZIP_FILE }} lambda_function.py utils.py

#       - name: Set AWS credentials
#         uses: aws-actions/configure-aws-credentials@v1
#         with:
#           aws-access-key-id: ${{ secrets.STAGING_AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.STAGING_AWS_SECRET_ACCESS_KEY }}
#           aws-region: us-west-1

#       - name: Setup Python 3.8
#         uses: actions/setup-python@v1
#         with:
#           python-version: 3.8

#       - name: create python layer and upload to s3
#         id: python_lambda_layer
#         env:
#           release_bucket: ${{env.TARGET_BUCKET}}
#           release_bucket_uri: s3://${{ env.TARGET_BUCKET }}/layers/job_management_layer.zip
#           release_id: job_management_layer.zip
#           release_key: layers/job_management_layer.zip
#           release_layer: job_management_layer
#         run: |
#           mkdir python
#           pip install -r requirements.txt -t python
#           echo building release $release_id
#           # zip it up
#           zip --quiet -r $release_id python          
#           # copy the file to S3 and install it in lambda layers
#           aws s3 cp $release_id $release_bucket_uri
#           echo "::set-output name=layer_version_arn::$(aws lambda publish-layer-version --layer-name $release_layer  --content S3Bucket=$release_bucket,S3Key=$release_key --compatible-runtimes python3.8 | jq .LayerVersionArn )"          
      
#       - name: Deploy to S3
#         run: |
#           aws s3 cp ${{ env.ZIP_FILE }} s3://${{ env.TARGET_BUCKET }}
#           echo "${{ steps.python_lambda_layer.outputs.layer_version_arn }}"
          
#       - name: AWS Lambda Update
#         run: |
#           aws lambda update-function-configuration --function-name ${{env.FUNCTION_NAME}} --layers ${{steps.python_lambda_layer.outputs.layer_version_arn}}
#           sleep 30s 
#           aws lambda update-function-code --function-name ${{env.FUNCTION_NAME}} --s3-bucket ${{ env.TARGET_BUCKET }} --s3-key ${{ env.ZIP_FILE }}